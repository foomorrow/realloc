{"version":3,"file":"index.js","sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 7e951f8b23a5066a9868","webpack:///./index.js","webpack:///./createObservableState.js","webpack:///./JSONPathCompiler.js","webpack:///./utils.js","webpack:///./actionCreatorFactory.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Realloc\"] = factory();\n\telse\n\t\troot[\"Realloc\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 7e951f8b23a5066a9868\n **/","import createObservableState from './createObservableState'\nimport actionCreatorFactory from './actionCreatorFactory'\nimport { Compiler, parseJSONPath } from './JSONPathCompiler'\n\nexport default {\n  createObservableState,\n  actionCreatorFactory,\n  Compiler,\n  parseJSONPath\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./index.js\n **/","import { parseJSONPath } from './JSONPathCompiler'\nimport actionCreatorFactory from './actionCreatorFactory'\nexport default function createObservableState(initialState = {}, options = {}){\n  let currentState = {\n    $:initialState\n  }\n  let subscribers = []\n  let broadcastMap = {}\n  function subscribe(callback){\n    subscribers = subscribers.concat(callback)\n    return () => {\n      subscribers = subscribers.filter((cb) => cb !== callback)\n    }\n  }\n  function getState(path){\n    if(!path){\n      return currentState.$\n    }else{\n      return ;\n    }\n  }\n  let triggerFlag = false\n  const createAction = actionCreatorFactory(currentState, broadcastMap, (nextState) => {\n    currentState.$ = nextState\n    if(triggerFlag === false){\n      triggerFlag = true\n      setTimeout(() => {\n        subscribers.forEach((cb) => cb(currentState.$))\n        triggerFlag = false\n      }, 1)\n    }\n  })\n  function watch(listenPaths, keyPath, fn, opts){\n    const parsedListenPaths = listenPaths.map((listenPath) => {\n      return parseJSONPath(listenPath).join('')\n    })\n    const action = createAction(keyPath, fn, opts)\n    parsedListenPaths.forEach((parsedListenPath) => {\n      if(!broadcastMap[parsedListenPath]){\n        broadcastMap[parsedListenPath] = [action]\n      }else{\n        broadcastMap[parsedListenPath] = broadcastMap[parsedListenPath].concat([action])\n      }\n    })\n    return () => {\n      parsedListenPaths.forEach((parsedListenPath) => {\n        broadcastMap[parsedListenPath] = broadcastMap[parsedListenPath].filter((a) => {\n          return a !== action\n        })\n      })\n    }\n  }\n  return {\n    getState,\n    subscribe,\n    createAction,\n    watch\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./createObservableState.js\n **/","import { stackProcess, range} from './utils'\n\nexport class Compiler {\n  constructor(exprs, notNormalized){\n    if(notNormalized !== false){\n      exprs = parseJSONPath(exprs)\n    }\n    this.exprArray = exprs.map((lex) => {\n      return lex.replace(/\\{([^\\{]*)\\}/g, ($0, $1) => {\n        return 'args' + (/^\\[\\d+\\]/.test($1) ? '' : '[0].') + $1 + ''\n      })\n    })\n  }\n  createMatcher(){\n    let lastIndex = this.exprArray.length - 1\n    return new Function('$', 'args', stackProcess(\"\", this.exprArray.map((expr, i) => {\n      if(i === 0){\n        return [\n          (input, ctx) => {\n            return input +\n                  'var matches = [], $0 = $, pwd0 = \"$\";\\n' +\n                  (i === lastIndex?(\n                  'matches.push({' +\n                    'pwd: [pwd0], ' +\n                    'name: null, ' +\n                    'value: $0' +\n                  '});\\n'\n                  ):'')\n          },\n          (input, ctx) => {\n            return input +\n                  '\\nreturn matches;'\n          }\n        ]\n      }else{\n        return this._parseExpr(expr, i, i === lastIndex)\n      }\n    })))\n  }\n  _parseExpr(expr, lv, isLast){\n    if('..' === expr){\n      return [\n        (input,ctx) => {\n          return input +\n          '\\n((function(){\\n' +\n              'var stop = false;var breakFn = function(){stop = true};\\n' +\n            '\\nreturn function recurfn'+lv+'(visit, rootCur, pwd, key){\\n' +\n                'pwd = pwd || [];\\n' +\n                'key = key || null;\\n' +\n                'visit(rootCur, key, pwd, breakFn);\\n' +\n                'newPwd = key ? pwd.concat(key) : pwd'\n              '\\nif(stop === false && typeof rootCur === \"object\"){\\n' +\n                '\\nfor(var i in rootCur){\\n'\n                  '\\nif(rootCur.hasOwnProperty(i) && typeof rootCur[i] === \"object\" && stop === false){\\n' +\n                    'recurfn'+lv+'(visit, rootCur[i], newPwd, i);\\n' +\n                  '}\\n' +\n                '}\\n' +\n              '}\\n' +\n            '}\\n' +\n          '}())(function(recur, key, pwd, breakFn){\\n' +\n            'var $'+lv+' = recur;\\n' +\n            (isLast?(\n            'matches.push({' +\n              'pwd: ['+range(0, lv - 1).map((i) => 'pwd' + i).join(', ')+'].concat(pwd),' +\n              'name: key,'+\n              'value: $' + lv +\n            '});\\n'\n            ):(\n            'var pwd' + lv + ' = key;\\n'\n            ))\n        },\n        (input, ctx) => {\n          return input +\n                  '\\n},$'+(lv - 1)+'))\\n'\n        }\n      ]\n    }else if('*' === expr){\n      return [\n        (input,ctx) => {\n          return input +\n                '\\nfor(var i'+lv+' in $'+(lv - 1)+'){\\n'+\n                    'if($'+(lv - 1)+'.hasOwnProperty(i'+lv+')){\\n'+\n                      'var $' + lv + ' = $'+(lv - 1)+'[i'+lv+'];\\n' +\n                      (isLast?(\n                      'matches.push({' +\n                        'pwd: ['+range(0, lv).map((i) => 'pwd' + i).join(', ')+'],' +\n                        'name: i'+lv+','+\n                        'value: $' + lv +\n                      '});\\n'\n                      ):(\n                      'var pwd' + lv + ' = i'+lv+';\\n'\n                      ))\n        },\n        (input, ctx) => {\n          return input +\n                  '\\n}\\n'+\n                '\\n}\\n'\n        }\n      ]\n    }else if(/^\\d+(,\\d+)*$/.test(expr)){\n      return [\n        (input,ctx) => {\n          return input +\n                '\\nvar k'+lv+' = ['+expr+'];\\n'+\n                '\\nfor(var i'+lv+' = 0; i'+lv+' < k'+lv+'.length; i'+lv+'++){\\n'+\n                    'var $' + lv + ' = $'+(lv - 1)+'[k'+lv+'[i'+lv+']];\\n' +\n                    (isLast?(\n                    'matches.push({' +\n                      'pwd: ['+range(0, lv).map((i) => 'pwd' + i).join(', ')+'],' +\n                      'name: k'+lv+'[i'+lv+'],'+\n                      'value: $' + lv +\n                    '});\\n'\n                    ):(\n                    'var pwd' + lv + ' = k'+lv+'[i'+lv+'];\\n'\n                    ))\n        },\n        (input, ctx) => {\n          return input +\n                '\\n}\\n'\n        }\n      ]\n    }else if(/^\\d+(:\\d+){0,2}$/.test(expr)){\n      return [\n        (input,ctx) => {\n          var indexes = range.apply(null, expr.split(':').map((i) => parseInt(i)))\n          return input +\n                '\\nvar k'+lv+' = ['+indexes.join(', ')+'];\\n'+\n                '\\nfor(var i'+lv+' = 0; i'+lv+' < k'+lv+'.length; i'+lv+'++){\\n'+\n                    'var $' + lv + ' = $'+(lv - 1)+'[k'+lv+'[i'+lv+']];\\n' +\n                    (isLast?(\n                    'matches.push({' +\n                      'pwd: ['+range(0, lv).map((i) => 'pwd' + i).join(', ')+'],' +\n                      'name: k'+lv+'[i'+lv+'],'+\n                      'value: $' + lv +\n                    '});\\n'\n                    ):(\n                    'var pwd' + lv + ' = k'+lv+'[i'+lv+'];\\n'\n                    ))\n        },\n        (input, ctx) => {\n          return input +\n                '\\n}\\n'\n        }\n      ]\n    }else if(/^\\?\\(.*\\)$/.test(expr)){\n      return [\n        (input, ctx) => {\n          return input +\n                '\\nfor(var i'+lv+' = 0; i' + lv + ' < $' + (lv - 1) + '.length; i'+lv+'++){\\n' +\n                    'if(' +\n                      expr.substring(1).replace(/@/g,'$'+(lv - 1)+'[i'+lv+']') +\n                    '){\\n'+\n                      'var $' + lv + ' = $'+(lv - 1)+'[i'+lv+'];\\n' +\n                      (isLast?(\n                      'matches.push({' +\n                        'pwd: ['+range(0, lv).map((i) => 'pwd' + i).join(', ')+'],' +\n                        'name: i'+lv+','+\n                        'value: $' + lv +\n                      '});\\n'\n                      ):(\n                      'var pwd' + lv + ' = i' + lv +';\\n'\n                      ))\n        },\n        (input, ctx) => {\n          return input +\n                  '\\n}\\n'+\n                '\\n}\\n'\n        }\n      ]\n    }else if(/^\\(.*\\)$/.test(expr)){\n      return [\n        (input, ctx) => {\n          return input +\n                'var k'+lv+ ' = ' + expr.replace(/@/g,'$' + (lv - 1)) + ';\\n' +\n                'var $' + lv + ' = $' + (lv - 1) + '[k' + lv + '];\\n' +\n                (isLast?(\n                'matches.push({' +\n                  'pwd: ['+range(0, lv).map((i) => 'pwd' + i).join(', ')+'],' +\n                  'name: k'+lv+',' +\n                  'value: $' + lv +\n                '});\\n'\n                ):(\n                'var pwd' + lv + ' = k' + lv +';\\n'\n                ))\n        }\n      ]\n    }else if(/^\\[.*\\]$/.test(expr)){\n      return [\n        (input, ctx) => {\n          var key = expr.substring(1, expr.length - 1)\n          return input +\n                'var k'+lv+' = ' + key + ';\\n' +\n                'var $' + lv + ' = $' + (lv - 1) + expr +';\\n' +\n                (isLast?(\n                'matches.push({' +\n                  'pwd: ['+range(0, lv).map((i) => 'pwd' + i).join(', ')+'], ' +\n                  'name: k'+lv+', ' +\n                  'value: $' + lv +\n                '});\\n'\n                ):(\n                'var pwd' + lv + ' = k' + lv +';\\n'\n                ))\n        }\n      ]\n    }else{\n      throw new Error('unexpected expression: '+expr+'')\n    }\n  }\n}\nexport const lexers = [\n  [\n    (input, ctx) => { // braces\n      var paramExprs = ctx.paramExprs = []\n      return input.replace(/\\{([^\\{]*)\\}/g, ($0, $1) => '#{' + (paramExprs.push($1) - 1) +'}')\n    },\n    (input, ctx) => {\n      var {paramExprs} = ctx\n      return input.map((p) => p.replace(/^#\\{(\\d+)\\}$/,($0, $1) => '[{' + paramExprs[$1] + '}]')\n                              //FIXME .replace(/(?=\\w+)#\\{(\\d+)\\}(?=\\w+)/g,($0, $1) => '\"+{' + paramExprs[$1] + '}+\"')\n                              .replace(/#\\{(\\d+)\\}/g, ($0, $1) => '{' + paramExprs[$1] + '}'))\n    }\n  ],\n  [\n    (input, ctx) => { // predict [(...)],[?(...)]\n      var predictExprs = ctx.predictExprs = []\n      return input.replace(/[\\['](\\??\\(.*?\\))[\\]']/g, ($0, $1) => ';##' + (predictExprs.push($1) - 1))\n    },\n    (input, ctx) => {\n      var {predictExprs} = ctx\n      return input.map((p) => p.replace(/^##(\\d+)$/, ($0, $1) => predictExprs[$1]))\n    }\n  ],\n  [\n    (input, ctx) => { // dot identifer\n      var identifers = ctx.identifers = []\n      return input.replace(/(?:\\.)([A-Z_$]+[0-9A-Z_$]*)/ig, ($0, $1) => ';###' + (identifers.push($1) - 1))\n    },\n    (input, ctx) => {\n      var {identifers} = ctx\n      return input.map((p) => p.replace(/^###(\\d+)$/, ($0, $1) => '[\"' + identifers[$1] + '\"]'))\n    }\n  ],\n  [\n    (input, ctx) => {\n      return input.replace(/[\\.\\[]/g, ';')\n    }\n  ],\n  [\n    (input, ctx) => {\n      return input.replace(/;;;|;;/g, ';..;').replace(/;$|'?\\]|'$/g, '')\n    }\n  ],\n  [\n    (input, ctx) => {\n      return input.split(';')\n    },\n    (input, ctx) => {\n      return input.map((p) => p.replace(/^(\\d+)$/, '[$1]'))\n    }\n  ]\n]\nexport function parseJSONPath(expr){\n  return stackProcess(expr, lexers)\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./JSONPathCompiler.js\n **/","\n/**\n *\n *\n *\n */\n\nvar ArrayProto = Array.prototype\n  , ObjProto = Object.prototype\n  , FuncProto = Function.prototype\n\nvar nativeIsArray      = Array.isArray\n  , nativeKeys         = Object.keys\n  , nativeBind         = FuncProto.bind\n  , nativeCreate       = Object.create\n  , hasOwnProperty     = ObjProto.hasOwnProperty\n  , toString           = ObjProto.toString\n  , push               = ArrayProto.push\n  , slice              = ArrayProto.slice\n  , nativeAssign       = Object.assign\n\n\nexport const isUndefined = function (obj){\n  return obj === void 0\n}\n\nexport const isObject = function (obj){\n  var type = typeof obj\n  return type === 'function' || type === 'object' && !!obj\n}\n\nexport const isArray = nativeIsArray || function (obj){\n  return toString.call(obj) === '[object Array]'\n}\n\nexport const isFunction = function (obj){\n  return typeof obj == 'function' || false\n}\n\nexport const has = function (obj, key){\n  return obj != null && hasOwnProperty.call(obj, key)\n}\n\nexport const pairs = function (obj){\n  var arr = []\n  for(var k in obj){\n    if(has(obj, k)){\n      arr.push([k, obj[k]])\n    }\n  }\n  return arr\n}\n\nexport const keys = nativeKeys || function (obj){\n  var keys = []\n  for (var key in obj) if (has(obj, key)) keys.push(key)\n  return keys\n}\n\nexport const assign = nativeAssign || function(target, ...sources){\n  sources.forEach((source) => {\n    keys(source).forEach((key) => {\n      target[key] = source[key]\n    })\n  })\n  return target\n}\n\nexport const clone = function (obj){\n  if(!obj) return obj\n  if(isArray(obj)){\n    return obj.slice()\n  }else{\n    return assign({}, obj)\n  }\n}\n\nexport const range = function range(start, stop, step){\n  if (stop == null) {\n    stop = start || 0;\n    start = 0;\n  }\n  step = step || 1;\n\n  var length = Math.max(Math.ceil((stop - start) / step), 0);\n  var range = Array(length);\n\n  for (var idx = 0; idx < length; idx++, start += step) {\n    range[idx] = start;\n  }\n  return range;\n}\n\nexport function stackProcess(expr, fns, context = {}){\n  var head = fns[0]\n    , tails = fns.slice(1)\n    , preProcessor = head[0]\n    , postProcessor = head[1] || ((a) => a)\n\n  var preResult = preProcessor(expr, context)\n  if(!tails.length){\n    return postProcessor(preResult, context)\n  }else{\n    return postProcessor(stackProcess(preResult, tails, context), context)\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./utils.js\n **/","import { clone } from './utils'\nimport { Compiler, parseJSONPath } from './JSONPathCompiler'\n\nexport default function actionCreatorFactory(stateParent, broadcastMap, collect){\n  return (keyPath, fn, opts) => {\n    const options = Object.assign({deps:[]}, opts)\n    const parsedKeyPath = parseJSONPath(keyPath)\n    const parsedKeyPathStr = parsedKeyPath.join('')\n    const compiler = new Compiler(parsedKeyPath, false)\n    const matcher = compiler.createMatcher()\n    const depsGetters = options.deps.map((kp) => (new Compiler(kp)).createMatcher())\n    const castFns = Object.keys(broadcastMap)\n                           .filter((v) => parsedKeyPathStr.indexOf(v) === 0)\n                           .map((k) => broadcastMap[k])\n                           .reduce((acc,i) => acc.concat(i), [])\n    return (...payloads) => {\n      var matchDeps = depsGetters.map((get) => get(stateParent.$, payloads).map((r) => r.value))\n      var execResults = matcher(stateParent.$, payloads).map((result) => {\n        return fn.apply(\n          null,\n          payloads.concat(\n            matchDeps\n          ).concat(\n            [\n              result.value,\n              (newValue) => {\n                var newCur = stateParent.$\n                  , oldCur = stateParent.$\n                result.pwd.slice(1).forEach((key) => {\n                  if(key){\n                    newCur[key] = clone(oldCur[key])\n                    newCur = newCur[key]\n                    oldCur = oldCur[key]\n                  }\n                })\n                if(result.name !== null){\n                  newCur[result.name] = newValue\n                  collect(stateParent.$)\n                }else{\n                  collect(newValue)\n                }\n\n              },\n              result\n            ]\n          )\n        )\n      })\n      castFns.forEach((fn) => fn.apply(null, []))\n      return execResults\n    }\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./actionCreatorFactory.js\n **/"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACtCA;AACA;;;AAAA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACPA;AACA;;;AAHA;AACA;AAAA;AACA;;;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3DA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;;;AAYA;AACA;AACA;AACA;AAEA;AASA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AArCA;AAsCA;AACA;AAEA;AAQA;AAEA;AAUA;AAAA;AAOA;AAEA;AAEA;AAEA;AACA;AAEA;AAMA;AAAA;AAOA;AAEA;AAGA;AAEA;AACA;AAEA;AAMA;AAAA;AAOA;AAEA;AAEA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AAMA;AAAA;AAOA;AAEA;AAEA;AAEA;AACA;AAEA;AAQA;AAAA;AAOA;AAEA;AAGA;AAEA;AACA;AAEA;AAKA;AAAA;AAOA;AAEA;AACA;AAEA;AACA;AAKA;AAAA;AAOA;AAEA;AACA;AACA;AACA;AACA;AA9MA;;;;AA+MA;;AAGA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;;AAIA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAIA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AAIA;AACA;AAIA;AACA;AAEA;AAAA;AAAA;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;AC/PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACrGA;AACA;AAJA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;","sourceRoot":""}